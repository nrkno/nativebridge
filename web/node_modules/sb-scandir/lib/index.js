'use strict';

var scanDirectory = function () {
  var _ref = _asyncToGenerator(function* (path, recursive, validate) {
    var itemStat = yield stat(path);
    if (itemStat.isFile()) {
      return [path];
    }
    if (!itemStat.isDirectory() || recursive === 0) {
      return [];
    }
    var contents = yield readdir(path);
    var results = yield Promise.all(contents.map(function (item) {
      var itemPath = _path2.default.join(path, item);
      if (validate(itemPath)) {
        return scanDirectory(itemPath, recursive === 1 ? 0 : 2, validate);
      }
      return [];
    }));
    return results.reduce(function (toReturn, current) {
      return toReturn.concat(current);
    }, []);
  });

  return function scanDirectory(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var stat = (0, _sbPromisify2.default)(_fs2.default.stat);
var readdir = (0, _sbPromisify2.default)(_fs2.default.readdir);

module.exports = function () {
  var _ref2 = _asyncToGenerator(function* (path) {
    var givenRecursive = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
    var givenValidate = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    (0, _assert2.default)(path && typeof path === 'string', 'path must be a valid string');
    (0, _assert2.default)(!givenValidate || typeof givenValidate === 'function', 'validate must be a valid function');

    var recursive = !!givenRecursive;
    var validate = givenValidate || function (itemPath) {
      return _path2.default.basename(itemPath).substr(0, 1) !== '.';
    };

    return yield scanDirectory(path, recursive ? 2 : 1, validate);
  });

  return function (_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();